<?php
/**
 * This file is part of Railt package.
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
declare(strict_types=1);

namespace Railt\Json\Json5;

use Railt\Lexer\Factory;
use Railt\Lexer\LexerInterface;
use Railt\Parser\Driver\Llk;
use Railt\Parser\Driver\Stateful;
use Railt\Parser\Grammar;
use Railt\Parser\GrammarInterface;
use Railt\Parser\ParserInterface;
use Railt\Parser\Rule\Alternation;
use Railt\Parser\Rule\Concatenation;
use Railt\Parser\Rule\Terminal;

/**
 * --- DO NOT EDIT THIS FILE ---
 *
 * Class BaseParser has been auto-generated.
 * Generated at: 07-02-2019 00:06:58
 *
 * --- DO NOT EDIT THIS FILE ---
 */
class BaseParser extends Stateful
{
    public const T_COMMENT = 'T_COMMENT';
    public const T_DOC_COMMENT = 'T_DOC_COMMENT';
    public const T_BRACKET_OPEN = 'T_BRACKET_OPEN';
    public const T_BRACKET_CLOSE = 'T_BRACKET_CLOSE';
    public const T_BRACE_OPEN = 'T_BRACE_OPEN';
    public const T_BRACE_CLOSE = 'T_BRACE_CLOSE';
    public const T_COLON = 'T_COLON';
    public const T_COMMA = 'T_COMMA';
    public const T_BOOL_TRUE = 'T_BOOL_TRUE';
    public const T_BOOL_FALSE = 'T_BOOL_FALSE';
    public const T_NULL = 'T_NULL';
    public const T_DOUBLE_QUOTED_STRING = 'T_DOUBLE_QUOTED_STRING';
    public const T_SINGLE_QUOTED_STRING = 'T_SINGLE_QUOTED_STRING';
    public const T_KEY = 'T_KEY';
    public const T_HEX_NUMBER = 'T_HEX_NUMBER';
    public const T_NUMBER = 'T_NUMBER';
    public const T_HTAB = 'T_HTAB';
    public const T_LF = 'T_LF';
    public const T_CR = 'T_CR';
    public const T_WHITESPACE = 'T_WHITESPACE';
    public const T_UTF32BE_BOM = 'T_UTF32BE_BOM';
    public const T_UTF32LE_BOM = 'T_UTF32LE_BOM';
    public const T_UTF16BE_BOM = 'T_UTF16BE_BOM';
    public const T_UTF16LE_BOM = 'T_UTF16LE_BOM';
    public const T_UTF8_BOM = 'T_UTF8_BOM';
    public const T_UTF7_BOM = 'T_UTF7_BOM';

    /**
     * Lexical tokens list.
     *
     * @var string[]
     */
    protected const LEXER_TOKENS = [
        self::T_COMMENT              => '//[^\\n]*\\n',
        self::T_DOC_COMMENT          => '/\\*.*?\\*/',
        self::T_BRACKET_OPEN         => '\\[',
        self::T_BRACKET_CLOSE        => '\\]',
        self::T_BRACE_OPEN           => '{',
        self::T_BRACE_CLOSE          => '}',
        self::T_COLON                => ':',
        self::T_COMMA                => ',',
        self::T_BOOL_TRUE            => 'true\\b',
        self::T_BOOL_FALSE           => 'false\\b',
        self::T_NULL                 => 'null\\b',
        self::T_DOUBLE_QUOTED_STRING => '"[^"\\\\]*(\\\\.[^"\\\\]*)*"',
        self::T_SINGLE_QUOTED_STRING => '\'[^\'\\\\]*(\\\\.[^\'\\\\]*)*\'',
        self::T_KEY                  => '[_A-Za-z][_0-9A-Za-z]*',
        self::T_HEX_NUMBER           => '\\-?0x([0-9a-fA-F]+)',
        self::T_NUMBER               => '\\-?(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][\\+\\-]?[0-9]+)?',
        self::T_HTAB                 => '\\x09',
        self::T_LF                   => '\\x0A',
        self::T_CR                   => '\\x0D',
        self::T_WHITESPACE           => '\\x20',
        self::T_UTF32BE_BOM          => '^\\x00\\x00\\xFE\\xFF',
        self::T_UTF32LE_BOM          => '^\\xFE\\xFF\\x00\\x00',
        self::T_UTF16BE_BOM          => '^\\xFE\\xFF',
        self::T_UTF16LE_BOM          => '^\\xFF\\xFE',
        self::T_UTF8_BOM             => '^\\xEF\\xBB\\xBF',
        self::T_UTF7_BOM             => '^\\x2B\\x2F\\x76\\x38\\x2B\\x2F\\x76\\x39\\x2B\\x2F\\x76\\x2B\\x2B\\x2F\\x76\\x2F',
    ];

    /**
     * List of skipped tokens.
     *
     * @var string[]
     */
    protected const LEXER_SKIPPED_TOKENS = [
        'T_COMMENT',
        'T_DOC_COMMENT',
        'T_HTAB',
        'T_LF',
        'T_CR',
        'T_WHITESPACE',
        'T_UTF32BE_BOM',
        'T_UTF32LE_BOM',
        'T_UTF16BE_BOM',
        'T_UTF16LE_BOM',
        'T_UTF8_BOM',
        'T_UTF7_BOM',
    ];

    /**
     * @var int
     */
    protected const LEXER_FLAGS = Factory::LOOKAHEAD;

    /**
     * List of rule delegates.
     *
     * @var string[]
     */
    protected const PARSER_DELEGATES = [
    ];

    /**
     * Parser root rule name.
     *
     * @var string
     */
    protected const PARSER_ROOT_RULE = 'Json';

    /**
     * @return ParserInterface
     * @throws \InvalidArgumentException
     * @throws \Railt\Lexer\Exception\BadLexemeException
     */
    protected function boot(): ParserInterface
    {
        return new Llk($this->bootLexer(), $this->bootGrammar());
    }

    /**
     * @return LexerInterface
     * @throws \InvalidArgumentException
     * @throws \Railt\Lexer\Exception\BadLexemeException
     */
    protected function bootLexer(): LexerInterface
    {
        return Factory::create(static::LEXER_TOKENS, static::LEXER_SKIPPED_TOKENS, static::LEXER_FLAGS);
    }

    /**
     * @return GrammarInterface
     */
    protected function bootGrammar(): GrammarInterface
    {
        return new Grammar([
            new Concatenation(0, ['Value'], null),
            (new Concatenation('Json', [0], 'Json'))->setDefaultId('Json'),
            new Concatenation(2, ['StringValue'], null),
            (new Concatenation('Value', [2], 'Value'))->setDefaultId('Value'),
            new Terminal(4, 'T_DOUBLE_QUOTED_STRING', true),
            new Concatenation(5, [4], 'StringValue'),
            new Terminal(6, 'T_SINGLE_QUOTED_STRING', true),
            new Concatenation(7, [6], 'StringValue'),
            (new Alternation('StringValue', [5, 7], null))->setDefaultId('StringValue'),
        ], static::PARSER_ROOT_RULE, static::PARSER_DELEGATES);
    }
}
